#summary Page sur la gestion des listes Qt côté QML dans Reyn Tweets
#labels Architecture

= Architecture des listes avec QML =

Au cours des développements de Reyn Tweets, il y a eu deux architectures différentes pour les listes. Le changement d'architecture a eu lieu à la révision SVN r456 puis il a été "annulé" (retour à l'ancienne architecture) à la révision r476.

== Architecture en cours(jusqu'à la révision r455 et depuis la révision r476) ==

Dans la vue, les listes sont des ListViews avec des ListModels derrière

La liste des objets dont on a besoin (Tweets, Users, ...) est dans le Contrôle.

Le délégué de la ListView va piocher l'entité dont il a besoin via une méthode {{{Entite * getEntite(int index);}}} (Entite = Tweet, User, etc.) du Contrôle. Pendant ce temps, le ListModel est constitué d'une liste de jsobject vides ({}) dont la longueur est celle de la liste dans le contrôle.

Lors d'une mise à jour, le Contrôle de l'entité simple passe la nouvelle valeur de l'entité sous forme d'un QVariant dans différents signaux jusqu'au Contrôle de la liste (via l'affichage de l'entité simple situé dans le délégué de la ListView). Le contrôle de la liste se charge ensuite de réajuster la longueur de la liste des jsobjects du ListModel.


=== Pourquoi cette architecture ? ===

  * On évite la manipulation du QML côté Qt avec des setContext(); et autres méthodes dans ce genre. *C'est même une ligne de conduite du code de Reyn Tweets. QML contexts in Qt parts of the code are EVIL (and bullshit).*
  * Mauvais interfaçage QML/JS (à mon avis). Incompatibilités entre jsobjects et les objets de QML et/ou objets Qt du programme déclarés via qmlRegisterTypes();. Idem avec les listes QML pour qui on ne peut faire facilement de customisation côté Qt et qui ne s'interfacent pas avec des Arrays JS.

=== Défauts ===
  * Mauvaise approche car les données à afficher dans la liste ne sont pas dans le ListModel.
  * Obligation de passer la valeur des nouveaux tweets lors des màj
  * Liste de jsobjects qui sert à rien si ce n'est sa longueur.

=== Avantage ===
  * Ne passe pas par l'usine à gaz (avis personnel) des QDeclarativeXXX et des xxx_cast<> à faire côté Qt.


== Architecture révisée éphémère (entre les révisions r456 et r476) ==

Dans la vue QML, les listes sont des ListViews avec des ListModels derrière

La liste des objets dont on a besoin (Tweets, Users, ...) est dans le Contrôle comme dans l'ancienne architecture.

La différence est que les contrôles ayant des listes (TimelineControl par exemple) mettent à disposition une propriété "variant_list" de type QVariantList. Cette propriété doit être synchronisée avec une nouvelle propriété "liste_variante" située dans le modèle de liste QML (ListModel), via un "property alias" par exemple. Les éléments de la propriété "liste_variante" (de type variant (QML) / QVariant (Qt)) sont indirectement insérés dans la liste de jsobjects du ListModel. En effet, comme les éléments de "liste_variante" ne sont pas des jsobjects, chaque élément est inséré dans le champ "entityVar" d'un jsobject qui est à son tour inséré dans la liste des jsobjects du ListModel.

Le délégué du ListView va désormais chercher les infos dont a besoin dans la liste des jsobjects du ListModel (au lieu du Contrôle auparavant), ce qui est plus dans la logique les ListViews et des ListModel derrière. Pour cela, le délégué récupère le contenu du champ "entityVar" contenu dans le jsobject. Ce contenu (de forme variant (QML) / QVariant (Qt)) est ensuite passé aux composants gérant une entité "simple" (Tweet, User, ... i.e. pas une liste type "Timeline"). Ces composants sont le panneau d'affichage QML (TweetPane pour les tweets) et le contrôle Qt derrière le panneau QML (TweetControl pour les tweets). Le panneau QML garde l'entité dans une propriété de type variant "variant_entity" qu'il synchronise avec une propriété correspondante de type QVariant(Map) dans le contrôle (via un "property alias"). Côté contrôle, cette propriété de type QVariant est représentée par un objet avec le "vrai type" de la propriété (Tweet, User, ...).

Lors d'une mise à jour du côté de l'entité simple, les composants gérant l'entité signalent que la propriété "variant_entity" a été modifiée. Le changement peut être ainsi pris en compte par la ListView via son délégué et la fonction JS onVariant_entityChanged. Lors de cette méthode, on communique la nouvelle valeur de "variant_entity" au contrôle derrière la liste qui se chargera de mettre la liste des entités à jour ainsi que "liste_variante" dans le ListModel.


=== Avantages par rapport à la précédente architecture ===
  * La nouvelle architecture respecte plus la philosophie des listes graphiques (ListViews) avec leur modèle de données (ListModel) derrière (pattern MVC).
  * La liste des jsobjects du ListModel contient des objects plus significatifs ("forme QVariant" des objects à afficher contre des jsobjects vides avant). Avant, seule la longueur de la liste avait un sens. Maintenant, il y a aussi son contenu.
  * Pas besoin de bouffer de la mémoire en passage de nouvelle valeur des entité simples lors des mises à jour.


=== Inconvénients par rapport à la précédente architecture ===
  * Propriétés supplémentaires à gérer.
  * Complexité supplémentaire avec le champ "entVar" des jsobjects de la liste des jsobjects du ListModel.
  * Plus de mémoire au final car il faut bien stocker les variant quelque part.

=== Évolutions possibles de cette seconde architecture ===
  * Réécriture des méthodes du ListModel pour qu'il aille chercher directement les infos nécessaires dans la "liste_variante" du ListModel au lieu de la liste des jsobjects. Cela éliminerait la complexité engendrée par l'encapsulation des éléments de "liste_variante" dans la liste des jsobjects. Et puis ça ferait des économies de mémoire.

